# Agent Memory — Conversation Persistence

## Overview

The application implements a **client-side memory** pattern: the agent is stateless and the web app (Chainlit client) owns all conversation history. Messages are persisted to Azure Cosmos DB and replayed to the agent on each request.

```
┌──────────────┐        ┌──────────────┐        ┌──────────────┐
│              │  HTTP   │              │  SDK   │              │
│   Browser    │◄──────►│   Web App    │◄──────►│  Cosmos DB   │
│  (Chainlit)  │        │  (Chainlit)  │        │  (NoSQL)     │
│              │        │              │        │              │
└──────────────┘        └──────┬───────┘        └──────────────┘
                               │
                               │ OpenAI Responses API
                               │ (stateless — full context
                               │  sent with each request)
                               ▼
                        ┌──────────────┐
                        │              │
                        │   KB Agent   │
                        │  (FastAPI)   │
                        │              │
                        └──────────────┘
```

**Key design decisions:**

- The **agent is stateless** — it receives the full conversation context with each request and returns a single response.
- The **web app owns the memory** — it maintains an in-memory `messages` list per session and persists it to Cosmos DB via Chainlit's data layer abstraction.
- Cosmos DB storage is **append-only** — steps and elements are never deleted from the document, only the in-memory context sent to the agent can be trimmed.

---

## Cosmos DB Schema

### Infrastructure

Deployed via Bicep (`infra/modules/cosmos-db.bicep`):

| Setting | Value |
|---|---|
| API | NoSQL |
| Capacity mode | Serverless |
| Consistency | Session |
| Database name | `kb-agent` |
| Container name | `conversations` |
| Partition key | `/userId` |
| TTL | `-1` (no expiry — conversations persist indefinitely) |
| Local auth | Disabled (Entra-only via managed identity) |

```bicep
resource conversationsContainer '...' = {
  parent: database
  name: 'conversations'
  properties: {
    resource: {
      id: 'conversations'
      partitionKey: {
        paths: ['/userId']
        kind: 'Hash'
      }
      indexingPolicy: {
        indexingMode: 'consistent'
        includedPaths: [ { path: '/*' } ]
        excludedPaths: [
          { path: '/messages/*' }   // steps/elements not indexed
          { path: '/"_etag"/?' }
        ]
      }
      defaultTtl: -1
    }
  }
}
```

### Document Schema

Each conversation thread is stored as a single Cosmos DB document:

```json
{
  "id": "<thread-id (UUID)>",
  "userId": "<user-identifier>",
  "name": "<auto-generated title from first user message>",
  "createdAt": "2026-02-26T10:30:00+00:00",
  "updatedAt": "2026-02-26T10:35:12+00:00",
  "steps": [
    {
      "id": "<step-uuid>",
      "threadId": "<thread-id>",
      "type": "user_message",
      "output": "What are the key components of Azure Content Understanding?",
      "createdAt": "2026-02-26T10:30:01+00:00"
    },
    {
      "id": "<step-uuid>",
      "threadId": "<thread-id>",
      "type": "assistant_message",
      "output": "Azure Content Understanding consists of...",
      "createdAt": "2026-02-26T10:30:05+00:00"
    }
  ],
  "elements": [
    {
      "id": "<element-uuid>",
      "threadId": "<thread-id>",
      "type": "text",
      "name": "Ref #1",
      "content": "### Ref #1 — Article Title\n**Section:** ...",
      "display": "side"
    }
  ],
  "metadata": {},
  "tags": []
}
```

**Users** are stored in the same container as separate documents with a special partition key:

```json
{
  "id": "user:local-user",
  "userId": "__users__",
  "identifier": "local-user",
  "displayName": null,
  "metadata": { "provider": "header" },
  "createdAt": "2026-02-26T10:00:00+00:00"
}
```

```
┌──────────────────────── conversations container ────────────────────────┐
│                                                                         │
│  Partition: userId = "local-user"                                       │
│  ┌───────────────────────────────────────────┐                          │
│  │  id: "abc-123"   (thread document)        │                          │
│  │  steps: [ {user_message}, {assistant}, …] │                          │
│  │  elements: [ {Ref #1}, {Ref #2}, …]       │                          │
│  ├───────────────────────────────────────────┤                          │
│  │  id: "def-456"   (thread document)        │                          │
│  │  steps: [ … ]                             │                          │
│  └───────────────────────────────────────────┘                          │
│                                                                         │
│  Partition: userId = "__users__"                                        │
│  ┌───────────────────────────────────────────┐                          │
│  │  id: "user:local-user"  (user document)   │                          │
│  └───────────────────────────────────────────┘                          │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## How Messages Are Saved

### 1. Session Initialisation (`on_chat_start`)

When a user opens the app, a new session is created with an empty message history:

```python
@cl.on_chat_start
async def on_chat_start() -> None:
    client = _create_agent_client()
    cl.user_session.set("client", client)
    cl.user_session.set("messages", [])        # empty in-memory history
    cl.user_session.set("user_id", _get_user_id())
```

### 2. Handling a User Message (`on_message`)

Each user message triggers this flow:

```
User types message
       │
       ▼
┌─────────────────────────┐
│ Append to in-memory list │  messages.append({"role": "user", "content": ...})
└────────────┬────────────┘
             │
             ▼
┌─────────────────────────┐
│ Trim context window      │  _trim_context(messages) — drops oldest if > 120K tokens
└────────────┬────────────┘
             │
             ▼
┌─────────────────────────┐
│ Build conversation       │  Prior messages serialised as "[role]: content"
│ context string           │  and sent as `instructions` parameter
└────────────┬────────────┘
             │
             ▼
┌─────────────────────────┐
│ Stream response from     │  client.responses.create(
│ agent via OpenAI API     │    model="kb-agent",
└────────────┬────────────┘    input=message.content,
             │                 instructions=conversation_context,
             ▼                 stream=True)
┌─────────────────────────┐
│ Append assistant reply   │  messages.append({"role": "assistant", "content": full_text})
│ to in-memory list        │
└────────────┬────────────┘
             │
             ▼
┌─────────────────────────┐
│ Chainlit auto-persists   │  Chainlit calls data layer methods:
│ to Cosmos DB             │  • update_thread()  — upsert thread doc
│                          │  • create_step()    — append step to doc
│                          │  • create_element() — append citation elements
└──────────────────────────┘
```

The key code for appending and sending context:

```python
@cl.on_message
async def on_message(message: cl.Message) -> None:
    client: OpenAI = cl.user_session.get("client")
    messages: list[dict] = cl.user_session.get("messages")

    # 1. Append new user message
    messages.append({"role": "user", "content": message.content})

    # 2. Trim to fit context window
    context = _trim_context(messages)

    # 3. Build conversation context for the agent
    input_parts = []
    for msg_item in context[:-1]:  # all except current
        input_parts.append(f"[{msg_item['role']}]: {msg_item['content']}")
    conversation_context = "\n".join(input_parts) if input_parts else None

    # 4. Stream response from agent
    response = client.responses.create(
        model="kb-agent",
        input=message.content,
        instructions=conversation_context,
        stream=True,
    )

    # ... stream tokens ...

    # 5. Save assistant reply to in-memory history
    messages.append({"role": "assistant", "content": full_text})
    cl.user_session.set("messages", messages)
```

### 3. Cosmos DB Persistence (Automatic)

Chainlit automatically calls the registered `CosmosDataLayer` methods during the message lifecycle. The data layer performs **upsert** operations on thread documents:

```python
async def create_step(self, step_dict: "StepDict") -> None:
    thread_id = step_dict.get("threadId")
    doc = self._read_thread_doc(thread_id)

    if not doc:
        # Auto-create thread document if it doesn't exist yet
        doc = {
            "id": thread_id,
            "userId": "local-user",
            "createdAt": now,
            "updatedAt": now,
            "steps": [],
            "elements": [],
        }

    # Append step to the document's steps array
    steps: list = doc.get("steps", [])
    steps.append(dict(step_dict))
    doc["steps"] = steps
    doc["updatedAt"] = datetime.now(timezone.utc).isoformat()

    # Auto-title from first user message (truncated to 80 chars)
    if not doc.get("name") and step_dict.get("type") == "user_message":
        output = step_dict.get("output", "")
        doc["name"] = output[:80] if output else "New conversation"

    self._container.upsert_item(doc)
```

The data layer is registered conditionally — only when `COSMOS_ENDPOINT` is configured:

```python
if config.cosmos_endpoint:
    @cl.data_layer
    def _get_data_layer():
        from app.data_layer import CosmosDataLayer
        return CosmosDataLayer()
else:
    logger.info("Cosmos DB not configured — conversation persistence disabled")
```

---

## How Conversations Are Resumed

### User-Facing Flow

Chainlit shows a conversation history sidebar when a data layer is active. Clicking a past thread triggers `on_chat_resume`:

```
User clicks past conversation
       │
       ▼
┌─────────────────────────┐
│ Chainlit calls           │  data_layer.get_thread(thread_id)
│ get_thread()             │  → reads full doc from Cosmos DB
└────────────┬────────────┘
             │
             ▼
┌─────────────────────────┐
│ on_chat_resume fires     │  Receives ThreadDict with all steps
└────────────┬────────────┘
             │
             ▼
┌─────────────────────────┐
│ Rebuild in-memory        │  Iterate steps, map type → role:
│ messages list            │    user_message  → {"role": "user", ...}
└────────────┬────────────┘    assistant_message → {"role": "assistant", ...}
             │
             ▼
┌─────────────────────────┐
│ Session ready            │  New messages will append to the
│                          │  rebuilt history
└──────────────────────────┘
```

```python
@cl.on_chat_resume
async def on_chat_resume(thread: ThreadDict) -> None:
    client = _create_agent_client()
    cl.user_session.set("client", client)
    cl.user_session.set("user_id", _get_user_id())

    # Rebuild messages from stored steps
    messages: list[dict] = []
    for step in thread.get("steps", []):
        step_type = step.get("type", "")
        output = step.get("output", "")
        if step_type == "user_message":
            messages.append({"role": "user", "content": output})
        elif step_type == "assistant_message":
            messages.append({"role": "assistant", "content": output})

    cl.user_session.set("messages", messages)
```

### Listing Past Threads

The sidebar calls `list_threads()` which queries Cosmos DB for the current user's threads ordered by `updatedAt`:

```python
async def list_threads(self, pagination, filters) -> PaginatedResponse[ThreadDict]:
    user_id = filters.userId or "local-user"
    clean_id = self._normalize_user_id(user_id)
    prefixed_id = f"user:{clean_id}"

    query = (
        "SELECT c.id, c.createdAt, c.name, c.userId, c.tags, c.metadata "
        "FROM c WHERE c.userId IN (@cleanId, @prefixedId) "
        "ORDER BY c.updatedAt DESC"
    )
    items = list(self._container.query_items(
        query=query, parameters=params,
        enable_cross_partition_query=True,
        max_item_count=page_size + 1,
    ))
    # ... build PaginatedResponse ...
```

---

## Context Window Management

The in-memory message list can grow unboundedly while Cosmos DB keeps the full history. Before sending context to the agent, the app trims oldest messages to stay within the LLM's context window:

```python
_MAX_CONTEXT_TOKENS = 128_000
_RESPONSE_HEADROOM = 8_000
_CHARS_PER_TOKEN = 4

def _trim_context(messages: list[dict], max_tokens: int | None = None) -> list[dict]:
    """Drop oldest messages if estimated tokens exceed the context window."""
    limit = max_tokens or (_MAX_CONTEXT_TOKENS - _RESPONSE_HEADROOM)
    total = sum(_estimate_tokens(m.get("content", "")) for m in messages)
    if total <= limit:
        return messages

    trimmed = list(messages)
    while len(trimmed) > 1:
        est = sum(_estimate_tokens(m.get("content", "")) for m in trimmed)
        if est <= limit:
            break
        trimmed.pop(0)
    return trimmed
```

```
Full conversation history (Cosmos DB — append-only, never trimmed):
┌────┬────┬────┬────┬────┬────┬────┬────┬────┬────┐
│ M1 │ M2 │ M3 │ M4 │ M5 │ M6 │ M7 │ M8 │ M9 │M10 │
└────┴────┴────┴────┴────┴────┴────┴────┴────┴────┘

In-memory context sent to agent (trimmed to fit 120K tokens):
                         ┌────┬────┬────┬────┬────┐
                         │ M6 │ M7 │ M8 │ M9 │M10 │
                         └────┴────┴────┴────┴────┘
                         ▲
                         │ oldest surviving message
```

**Important:** Trimming only affects the in-memory context sent to the agent. The full conversation remains in Cosmos DB for resumption and history display.

---

## Agent Statelessness

The KB Agent (`src/agent/main.py`) is intentionally stateless. It receives context via the OpenAI Responses API:

| API Field | Purpose |
|---|---|
| `input` | Current user message |
| `instructions` | Serialised prior conversation context (`"[user]: ...\n[assistant]: ..."`) |

```python
class ResponsesRequest(BaseModel):
    input: str                          # current message
    instructions: str | None = None     # conversation history
    metadata: dict[str, Any] | None = None
    stream: bool = False
```

The agent processes the request, runs tool calls (search, image analysis), and returns a streamed response. It retains no state between requests.

---

## Authentication & User Identity

User identity determines the Cosmos DB partition key and controls which threads are visible:

```
Request arrives
     │
     ▼
┌────────────────────────┐
│ header_auth_callback   │  Checks X-MS-CLIENT-PRINCIPAL-ID (Azure Easy Auth)
│                        │  Falls back to "local-user" for dev
└────────┬───────────────┘
         │
         ▼
┌────────────────────────┐
│ _get_user_id()         │  Extracts identifier from session
│                        │  Used as userId partition key in Cosmos
└────────────────────────┘
```

The `_normalize_user_id()` helper strips the `user:` prefix that Chainlit adds, keeping the partition key consistent:

```python
@staticmethod
def _normalize_user_id(user_id: str | None) -> str:
    if not user_id:
        return "local-user"
    return user_id[len("user:"):] if user_id.startswith("user:") else user_id
```

---

## Graceful Degradation

The entire persistence layer is **optional**. If `COSMOS_ENDPOINT` is not set or the connection fails:

1. No data layer is registered → Chainlit runs without persistence
2. The conversation history sidebar is hidden
3. In-memory `messages` list still works for the current session
4. The agent still receives conversation context — only cross-session persistence is lost

```python
def _get_cosmos_client() -> CosmosClient | None:
    try:
        _cosmos_client = CosmosClient(
            url=config.cosmos_endpoint,
            credential=DefaultAzureCredential(),
        )
        return _cosmos_client
    except Exception:
        _cosmos_client_failed = True
        logger.warning(
            "Could not connect to Cosmos DB — running WITHOUT "
            "conversation persistence."
        )
        return None
```

---

## Summary

| Concern | Implementation |
|---|---|
| **In-memory history** | `cl.user_session.get("messages")` — list of `{"role", "content"}` dicts |
| **Persistent storage** | Cosmos DB NoSQL, serverless, `conversations` container |
| **Partition key** | `/userId` (user identifier, e.g. `"local-user"`) |
| **Document model** | One document per thread, steps and elements embedded |
| **Saving messages** | Chainlit auto-calls `create_step()` → upsert thread doc |
| **Resuming** | `on_chat_resume()` rebuilds `messages` from stored steps |
| **Context trimming** | `_trim_context()` drops oldest messages to fit 120K token window |
| **Agent model** | Stateless — full context sent via `instructions` field each request |
| **Auth** | Azure Easy Auth headers or `"local-user"` fallback |
| **Degradation** | Runs without persistence if Cosmos DB is unavailable |
