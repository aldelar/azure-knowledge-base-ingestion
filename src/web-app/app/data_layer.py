"""Cosmos DB-backed data layer for Chainlit conversation persistence.

Stores conversations as documents in an Azure Cosmos DB NoSQL container.
Each document represents one conversation thread with an embedded messages
array (append-only — never trimmed).

Document schema
---------------
::

    {
        "id": "<thread-id (UUID)>",
        "userId": "<user-id>",
        "title": "<auto-generated from first message>",
        "createdAt": "<ISO 8601>",
        "updatedAt": "<ISO 8601>",
        "steps": [ ... ],          # serialised StepDict objects
        "elements": [ ... ],       # serialised ElementDict objects
        "metadata": { ... },
        "tags": [ ... ]
    }
"""

from __future__ import annotations

import logging
import uuid
from datetime import datetime, timezone
from typing import TYPE_CHECKING, Dict, List, Optional

from azure.cosmos import CosmosClient, PartitionKey
from azure.cosmos.exceptions import CosmosResourceNotFoundError
from azure.identity import DefaultAzureCredential
from chainlit.data import BaseDataLayer
from chainlit.types import (
    Feedback,
    PageInfo,
    Pagination,
    PaginatedResponse,
    ThreadFilter,
)

from app.config import config

if TYPE_CHECKING:
    from chainlit.element import ElementDict
    from chainlit.step import StepDict
    from chainlit.types import ThreadDict
    from chainlit.user import PersistedUser, User

logger = logging.getLogger(__name__)

# ---------------------------------------------------------------------------
# Cosmos client singleton
# ---------------------------------------------------------------------------

_cosmos_client: CosmosClient | None = None
_cosmos_client_failed: bool = False


def _get_cosmos_client() -> CosmosClient | None:
    """Return a module-level Cosmos client (created on first call).

    Returns ``None`` if the connection cannot be established (e.g. firewall
    or RBAC misconfiguration).  The caller must handle the ``None`` case
    gracefully so the app can still run without persistence.
    """
    global _cosmos_client, _cosmos_client_failed
    if _cosmos_client is not None:
        return _cosmos_client
    if _cosmos_client_failed:
        return None
    try:
        _cosmos_client = CosmosClient(
            url=config.cosmos_endpoint,
            credential=DefaultAzureCredential(),
        )
        return _cosmos_client
    except Exception:
        _cosmos_client_failed = True
        logger.warning(
            "Could not connect to Cosmos DB at %s — running WITHOUT "
            "conversation persistence.  Fix the firewall / RBAC and restart.",
            config.cosmos_endpoint,
            exc_info=True,
        )
        return None


# ---------------------------------------------------------------------------
# Data layer implementation
# ---------------------------------------------------------------------------


class CosmosDataLayer(BaseDataLayer):
    """Chainlit ``BaseDataLayer`` backed by Azure Cosmos DB (NoSQL / serverless).

    The layer stores conversation threads as documents partitioned by
    ``/userId``.  Steps and elements are embedded inside each document.

    Users are persisted as separate documents (partition ``__users__``).

    The Cosmos container uses ``/userId`` as partition key.  When only a
    ``thread_id`` is available (no user context), a cross-partition query
    is used to locate the document.
    """

    def __init__(self) -> None:
        client = _get_cosmos_client()
        if client is not None:
            db = client.get_database_client(config.cosmos_database_name)
            self._container = db.get_container_client("conversations")
            logger.info(
                "CosmosDataLayer initialised (database=%s, container=conversations)",
                config.cosmos_database_name,
            )
        else:
            self._container = None  # type: ignore[assignment]
            logger.warning("CosmosDataLayer running in degraded mode (no persistence)")

    @staticmethod
    def _user_identifier(doc: dict) -> str:
        """Derive the clean user identifier from a thread document.

        Chainlit passes ``user.id`` (e.g. ``"user:local-user"``) as the
        ``user_id`` argument to ``update_thread``, but the auth check on
        resume compares ``thread["userIdentifier"]`` against
        ``user.identifier`` (e.g. ``"local-user"``).  This helper strips
        the ``user:`` prefix so the values match.
        """
        uid = doc.get("userIdentifier") or doc.get("userId", "")
        if uid.startswith("user:"):
            return uid[len("user:"):]
        return uid

    def _read_thread_doc(self, thread_id: str) -> dict | None:
        """Read a thread document using a cross-partition query by id.

        Point reads need the partition key (userId) which the Chainlit API
        does not always supply.  A SELECT-by-id query is the next best
        option — the ``id`` field is always indexed.
        """
        if not self._container:
            return None
        items = list(
            self._container.query_items(
                query="SELECT * FROM c WHERE c.id = @id",
                parameters=[{"name": "@id", "value": thread_id}],
                enable_cross_partition_query=True,
                max_item_count=1,
            )
        )
        return items[0] if items else None

    # ------------------------------------------------------------------
    # User management
    # ------------------------------------------------------------------

    async def get_user(self, identifier: str) -> Optional[PersistedUser]:
        from chainlit.user import PersistedUser

        if not self._container:
            return None
        try:
            doc = self._container.read_item(
                item=f"user:{identifier}",
                partition_key="__users__",
            )
            return PersistedUser(
                id=doc["id"],
                identifier=doc.get("identifier", identifier),
                display_name=doc.get("displayName"),
                metadata=doc.get("metadata", {}),
                createdAt=doc.get("createdAt", ""),
            )
        except CosmosResourceNotFoundError:
            return None

    async def create_user(self, user: User) -> Optional[PersistedUser]:
        from chainlit.user import PersistedUser

        now = datetime.now(timezone.utc).isoformat()
        if not self._container:
            return PersistedUser(
                id=f"user:{user.identifier}",
                identifier=user.identifier,
                display_name=user.display_name,
                metadata=user.metadata,
                createdAt=now,
            )
        doc = {
            "id": f"user:{user.identifier}",
            "userId": "__users__",
            "identifier": user.identifier,
            "displayName": user.display_name,
            "metadata": user.metadata,
            "createdAt": now,
        }
        self._container.upsert_item(doc)
        return PersistedUser(
            id=doc["id"],
            identifier=user.identifier,
            display_name=user.display_name,
            metadata=user.metadata,
            createdAt=now,
        )

    # ------------------------------------------------------------------
    # Feedback (stored as thread metadata — minimal implementation)
    # ------------------------------------------------------------------

    async def upsert_feedback(self, feedback: Feedback) -> str:
        feedback_id = feedback.id or str(uuid.uuid4())
        logger.debug("Feedback upserted: %s (no-op storage)", feedback_id)
        return feedback_id

    async def delete_feedback(self, feedback_id: str) -> bool:
        logger.debug("Feedback deleted: %s (no-op)", feedback_id)
        return True

    # ------------------------------------------------------------------
    # Elements
    # ------------------------------------------------------------------

    @staticmethod
    def _element_to_dict(element) -> dict:
        """Convert a Chainlit Element object or ElementDict to a plain dict."""
        if isinstance(element, dict):
            return element
        # Chainlit may pass an Element object (Text, Image, …) instead of a
        # TypedDict.  Pull the relevant attributes into a plain dict.
        d: dict = {}
        for key in (
            "id", "threadId", "type", "url", "name", "display",
            "language", "size", "page", "forId", "mime",
        ):
            # Element objects use snake_case attrs; map threadId → thread_id
            attr = "thread_id" if key == "threadId" else "for_id" if key == "forId" else key
            val = getattr(element, attr, None)
            if val is not None:
                d[key] = val
        # Content may be stored as .content or .output
        content = getattr(element, "content", None) or getattr(element, "output", None)
        if content is not None:
            d["content"] = content
        return d

    async def create_element(self, element: "ElementDict") -> None:
        """Append element to its parent thread document."""
        if not self._container:
            return
        el_dict = self._element_to_dict(element)
        thread_id = el_dict.get("threadId")
        if not thread_id:
            return
        doc = self._read_thread_doc(thread_id)
        if not doc:
            logger.warning("create_element: thread %s not found", thread_id)
            return
        elements: list = doc.get("elements", [])
        elements = [e for e in elements if e.get("id") != el_dict.get("id")]
        elements.append(el_dict)
        doc["elements"] = elements
        doc["updatedAt"] = datetime.now(timezone.utc).isoformat()
        self._container.upsert_item(doc)

    async def get_element(
        self, thread_id: str, element_id: str
    ) -> Optional[ElementDict]:
        doc = self._read_thread_doc(thread_id)
        if doc:
            for el in doc.get("elements", []):
                if el.get("id") == element_id:
                    return el  # type: ignore[return-value]
        return None

    async def delete_element(
        self, element_id: str, thread_id: Optional[str] = None
    ) -> None:
        if not self._container:
            return
        if not thread_id:
            return
        doc = self._read_thread_doc(thread_id)
        if not doc:
            return
        doc["elements"] = [
            e for e in doc.get("elements", []) if e.get("id") != element_id
        ]
        doc["updatedAt"] = datetime.now(timezone.utc).isoformat()
        self._container.upsert_item(doc)

    # ------------------------------------------------------------------
    # Steps (messages)
    # ------------------------------------------------------------------

    async def create_step(self, step_dict: "StepDict") -> None:
        if not self._container:
            return
        thread_id = step_dict.get("threadId")
        if not thread_id:
            return
        doc = self._read_thread_doc(thread_id)
        if not doc:
            # Thread document may not yet exist (Chainlit fires step events
            # before update_thread in some flows).  Create it on the fly.
            now = datetime.now(timezone.utc).isoformat()
            doc = {
                "id": thread_id,
                "userId": "local-user",
                "createdAt": now,
                "updatedAt": now,
                "steps": [],
                "elements": [],
            }
            logger.debug("create_step: auto-created thread %s", thread_id)
        steps: list = doc.get("steps", [])
        steps.append(dict(step_dict))
        doc["steps"] = steps
        doc["updatedAt"] = datetime.now(timezone.utc).isoformat()

        # Auto-title: use first user message (truncated to 80 chars)
        if not doc.get("name") and step_dict.get("type") == "user_message":
            output = step_dict.get("output", "")
            doc["name"] = output[:80] if output else "New conversation"

        self._container.upsert_item(doc)

    async def update_step(self, step_dict: "StepDict") -> None:
        if not self._container:
            return
        thread_id = step_dict.get("threadId")
        if not thread_id:
            return
        doc = self._read_thread_doc(thread_id)
        if not doc:
            # Thread document may not yet exist — create it on the fly.
            now = datetime.now(timezone.utc).isoformat()
            doc = {
                "id": thread_id,
                "userId": "local-user",
                "createdAt": now,
                "updatedAt": now,
                "steps": [],
                "elements": [],
            }
            logger.debug("update_step: auto-created thread %s", thread_id)
        steps: list = doc.get("steps", [])
        step_id = step_dict.get("id")
        # Replace existing step or append
        replaced = False
        for i, s in enumerate(steps):
            if s.get("id") == step_id:
                steps[i] = dict(step_dict)
                replaced = True
                break
        if not replaced:
            steps.append(dict(step_dict))
        doc["steps"] = steps
        doc["updatedAt"] = datetime.now(timezone.utc).isoformat()
        self._container.upsert_item(doc)

    async def delete_step(self, step_id: str) -> None:
        # Cannot determine thread_id from step_id alone — no-op
        logger.debug("delete_step %s (no-op without thread context)", step_id)

    # ------------------------------------------------------------------
    # Threads
    # ------------------------------------------------------------------

    async def get_thread_author(self, thread_id: str) -> str:
        doc = self._read_thread_doc(thread_id)
        if not doc:
            return ""
        return self._user_identifier(doc)

    async def delete_thread(self, thread_id: str) -> None:
        if not self._container:
            return
        doc = self._read_thread_doc(thread_id)
        if doc:
            user_id = doc.get("userId", thread_id)
            try:
                self._container.delete_item(item=thread_id, partition_key=user_id)
                logger.info("Thread deleted: %s", thread_id)
            except CosmosResourceNotFoundError:
                pass

    async def list_threads(
        self,
        pagination: Pagination,
        filters: ThreadFilter,
    ) -> PaginatedResponse[ThreadDict]:
        """List conversation threads for the current user, ordered by most recent."""
        if not self._container:
            return PaginatedResponse(
                pageInfo=PageInfo(hasNextPage=False, startCursor=None, endCursor=None),
                data=[],
            )
        user_id = filters.userId or "local-user"
        clean_id = self._normalize_user_id(user_id)
        # Also look for legacy docs whose partition still has the
        # "user:" prefix (written before the normalisation fix).
        prefixed_id = f"user:{clean_id}"
        page_size = pagination.first or 20

        query = (
            "SELECT c.id, c.createdAt, c.name, c.userId, c.tags, c.metadata "
            "FROM c WHERE c.userId IN (@cleanId, @prefixedId) "
            "ORDER BY c.updatedAt DESC"
        )
        params: list[dict] = [
            {"name": "@cleanId", "value": clean_id},
            {"name": "@prefixedId", "value": prefixed_id},
        ]

        items = list(
            self._container.query_items(
                query=query,
                parameters=params,
                enable_cross_partition_query=True,
                max_item_count=page_size + 1,
            )
        )

        has_next = len(items) > page_size
        items = items[:page_size]

        threads: list[ThreadDict] = []
        for item in items:
            threads.append(
                {
                    "id": item["id"],
                    "createdAt": item.get("createdAt", ""),
                    "name": item.get("name"),
                    "userId": item.get("userId"),
                    "userIdentifier": self._user_identifier(item),
                    "tags": item.get("tags"),
                    "metadata": item.get("metadata"),
                    "steps": [],
                    "elements": [],
                }
            )

        return PaginatedResponse(
            pageInfo=PageInfo(
                hasNextPage=has_next,
                startCursor=threads[0]["id"] if threads else None,
                endCursor=threads[-1]["id"] if threads else None,
            ),
            data=threads,
        )

    async def get_thread(self, thread_id: str) -> Optional[ThreadDict]:
        doc = self._read_thread_doc(thread_id)
        if not doc:
            return None
        return {
            "id": doc["id"],
            "createdAt": doc.get("createdAt", ""),
            "name": doc.get("name"),
            "userId": doc.get("userId"),
            "userIdentifier": self._user_identifier(doc),
            "tags": doc.get("tags"),
            "metadata": doc.get("metadata"),
            "steps": doc.get("steps", []),
            "elements": doc.get("elements", []),
        }

    @staticmethod
    def _normalize_user_id(user_id: str | None) -> str:
        """Strip the ``user:`` prefix that Chainlit adds to persisted user IDs.

        Chainlit passes ``user.id`` (e.g. ``"user:local-user"``) to
        ``update_thread`` rather than ``user.identifier``.  Stripping the
        prefix keeps the ``userId`` partition key consistent with the
        bare identifier used everywhere else.
        """
        if not user_id:
            return "local-user"
        return user_id[len("user:"):] if user_id.startswith("user:") else user_id

    async def update_thread(
        self,
        thread_id: str,
        name: Optional[str] = None,
        user_id: Optional[str] = None,
        metadata: Optional[Dict] = None,
        tags: Optional[List[str]] = None,
    ) -> None:
        if not self._container:
            return
        now = datetime.now(timezone.utc).isoformat()
        clean_user_id = self._normalize_user_id(user_id)

        # Try to read existing document via cross-partition query
        doc = self._read_thread_doc(thread_id)

        if not doc:
            # Thread doesn't exist yet — create it.
            doc = {
                "id": thread_id,
                "userId": clean_user_id,
                "createdAt": now,
                "steps": [],
                "elements": [],
            }

        if name is not None:
            doc["name"] = name
        if user_id is not None:
            doc["userId"] = clean_user_id
        if metadata is not None:
            doc["metadata"] = metadata
        if tags is not None:
            doc["tags"] = tags
        doc["updatedAt"] = now

        self._container.upsert_item(doc)

    # ------------------------------------------------------------------
    # Misc
    # ------------------------------------------------------------------

    async def build_debug_url(self) -> str:
        return ""

    async def close(self) -> None:
        logger.info("CosmosDataLayer closed")

    async def get_favorite_steps(self, user_id: str) -> List[StepDict]:
        return []
